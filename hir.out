//! Library for collecting and packing resources into a bundle with a manifest
//! file which describes those resources.
//!
//! A [`Bundle`](crate::Bundle) contains a [`Manifest`](crate::Manifest) as well as any number of arbitrary,
//! opaque resources in the form of [`ResourceBytes`](crate::ResourceBytes).
//! A Bundle can be serialized and written to a file.
//!
//! A Bundle can also be [packed](Bundle::pack_yaml) and [unpacked](Bundle::unpack_yaml),
//! via the `"packing"` feature.
//! Bundle packing is performed by following the [`Location`](crate::Location)s specified in the
//! Manifest as "Bundled", and pulling them into the Bundle that way.
//! Unpacking is done by specifying a target directory and creating a new file
//! for each resource at a relative path specified by the Manifest.

#![warn(missing_docs)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;

mod bundle {


    use crate::{};
    use crate::error::{};
    use crate::error::BundleError;
    use crate::error::MrBundleResult;
    use crate::location::Location;
    use crate::manifest::Manifest;
    use crate::resource::ResourceBytes;
    use holochain_util::ffs;
    use serde::{};
    use serde::de::DeserializeOwned;
    use serde::Deserialize;
    use serde::Serialize;
    use std::{};
    use std::borrow::Cow;
    use std::collections::{};
    use std::collections::BTreeMap;
    use std::collections::HashMap;
    use std::collections::HashSet;
    use std::path::{};
    use std::path::Path;
    use std::path::PathBuf;
    type ResourceMap = BTreeMap<PathBuf, ResourceBytes>;
    /// A Manifest bundled together, optionally, with the Resources that it describes.
    /// This is meant to be serialized for standalone distribution, and deserialized
    /// by the receiver.
    ///
    /// The manifest may describe locations of resources not included in the Bundle.
    struct Bundle<M> where M: Manifest {
        /// The manifest describing the resources that compose this bundle.
        #[serde(bound(deserialize = "M: DeserializeOwned"))]
        manifest: M,
        /// The full or partial resource data. Each entry must correspond to one
        /// of the Bundled Locations specified by the Manifest. Bundled Locations
        /// are always relative paths (relative to the root_dir).
        resources: ResourceMap,
        /// Since the Manifest may contain local paths referencing unbundled files,
        /// on the local filesystem, we must have an absolute path at runtime for
        /// normalizing those locations.
        ///
        /// Passing None is a runtime assertion that the manifest contains only
        /// absolute local paths. If this assertion fails,
        /// **resource resolution will panic!**
        #[serde(skip)]
        root_dir: Option<PathBuf>,
    }
    #[automatically_derived]
    impl <M> ::core::fmt::Debug for Bundle<M> where M: ::core::fmt::Debug,
        M: Manifest {
        fn fmt<'_, '_,
            '_>(self: &'_ Self, f: &'_ mut ::core::fmt::Formatter<>)
            ->
                ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(f,
                    "Bundle", "manifest", &self.manifest, "resources",
                    &self.resources, "root_dir", &&self.root_dir)
            }
    }
    #[automatically_derived]
    impl <M> ::core::marker::StructuralPartialEq for Bundle<M> where
        M: Manifest {
    }
    #[automatically_derived]
    impl <M> ::core::cmp::PartialEq for Bundle<M> where
        M: ::core::cmp::PartialEq, M: Manifest {
        #[inline]
        fn eq<'_, '_>(self: &'_ Self, other: &'_ Bundle<M>)
            ->
                bool {
                self.manifest == other.manifest &&
                        self.resources == other.resources &&
                    self.root_dir == other.root_dir
            }
    }
    #[automatically_derived]
    impl <M> ::core::marker::StructuralEq for Bundle<M> where M: Manifest { }
    #[automatically_derived]
    impl <M> ::core::cmp::Eq for Bundle<M> where M: ::core::cmp::Eq,
        M: Manifest {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq<'_>(self: &'_ Self)
            ->
                () {
                let _: ::core::cmp::AssertParamIsEq<M>;
                let _: ::core::cmp::AssertParamIsEq<ResourceMap>;
                let _: ::core::cmp::AssertParamIsEq<Option<PathBuf>>;
            }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () =
        {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[allow(unused_macros)]
                macro_rules! try {
                    ($__expr : expr) =>
                    {
                        match $__expr
                        {
                            _serde :: __private :: Ok(__val) => __val, _serde ::
                            __private :: Err(__err) =>
                            { return _serde :: __private :: Err(__err) ; }
                        }
                    }
                }
                #[automatically_derived]
                impl <M> _serde::Serialize for Bundle<M> where M: Manifest,
                    M: _serde::Serialize {
                    fn serialize<__S, '_>(self: &'_ Self, __serializer: __S)
                        -> _serde::__private::Result<__S::Ok, __S::Error> where
                        __S: _serde::Serializer {
                            let mut __serde_state =
                                match _serde::Serializer::serialize_struct(__serializer,
                                                "Bundle", false as usize + 1 + 1) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                            match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                            "manifest", &self.manifest) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                };
                            match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                            "resources", &self.resources) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                };
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                }
            };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () =
        {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[allow(unused_macros)]
                macro_rules! try {
                    ($__expr : expr) =>
                    {
                        match $__expr
                        {
                            _serde :: __private :: Ok(__val) => __val, _serde ::
                            __private :: Err(__err) =>
                            { return _serde :: __private :: Err(__err) ; }
                        }
                    }
                }
                #[automatically_derived]
                impl <'de, M> _serde::Deserialize<'de> for Bundle<M> where
                    M: Manifest, M: DeserializeOwned {
                    fn deserialize<__D>(__deserializer: __D)
                        -> _serde::__private::Result<Self, __D::Error> where
                        __D: _serde::Deserializer<'de> {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field { __field0, __field1, __ignore, }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            impl <'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type
                                Value
                                =
                                __Field;
                                fn expecting<'_, '_,
                                    '_>(self: &'_ Self,
                                    __formatter: &'_ mut _serde::__private::Formatter<>)
                                    ->
                                        _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(__formatter,
                                            "field identifier")
                                    }
                                fn visit_u64<__E>(self: Self, __value: u64)
                                    -> _serde::__private::Result<Self::Value, __E> where
                                    __E: _serde::de::Error {
                                        match __value {
                                                0u64 => _serde::__private::Ok(__Field::__field0),
                                                1u64 => _serde::__private::Ok(__Field::__field1),
                                                _ => _serde::__private::Ok(__Field::__ignore),
                                            }
                                    }
                                fn visit_str<__E, '_>(self: Self, __value: &'_ str)
                                    -> _serde::__private::Result<Self::Value, __E> where
                                    __E: _serde::de::Error {
                                        match __value {
                                                "manifest" => _serde::__private::Ok(__Field::__field0),
                                                "resources" => _serde::__private::Ok(__Field::__field1),
                                                _ => { _serde::__private::Ok(__Field::__ignore) }
                                            }
                                    }
                                fn visit_bytes<__E, '_>(self: Self, __value: &'_ [u8])
                                    -> _serde::__private::Result<Self::Value, __E> where
                                    __E: _serde::de::Error {
                                        match __value {
                                                b"manifest" => _serde::__private::Ok(__Field::__field0),
                                                b"resources" => _serde::__private::Ok(__Field::__field1),
                                                _ => { _serde::__private::Ok(__Field::__ignore) }
                                            }
                                    }
                            }
                            impl <'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(__deserializer: __D)
                                    -> _serde::__private::Result<Self, __D::Error> where
                                    __D: _serde::Deserializer<'de> {
                                        _serde::Deserializer::deserialize_identifier(__deserializer,
                                            __FieldVisitor)
                                    }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de, M> where M: Manifest,
                                M: DeserializeOwned {
                                marker: _serde::__private::PhantomData<Bundle<M>>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            impl <'de, M> _serde::de::Visitor<'de> for __Visitor<'de, M>
                                where M: Manifest, M: DeserializeOwned {
                                type
                                Value
                                =
                                Bundle<M>;
                                fn expecting<'_, '_,
                                    '_>(self: &'_ Self,
                                    __formatter: &'_ mut _serde::__private::Formatter<>)
                                    ->
                                        _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(__formatter,
                                            "struct Bundle")
                                    }
                                #[inline]
                                fn visit_seq<__A>(self: Self, mut __seq: __A)
                                    -> _serde::__private::Result<Self::Value, __A::Error> where
                                    __A: _serde::de::SeqAccess<'de> {
                                        let __field0 =
                                            match match _serde::de::SeqAccess::next_element::<M>(&mut __seq)
                                                                    {
                                                                _serde::__private::Ok(__val) => __val,
                                                                _serde::__private::Err(__err) => {
                                                                    return _serde::__private::Err(__err);
                                                                }
                                                            } {
                                                    _serde::__private::Some(__value) => __value,
                                                    _serde::__private::None => {
                                                        return _serde::__private::Err(_serde::de::Error::invalid_length(0usize,
                                                                    &"struct Bundle with 2 elements"));
                                                    }
                                                };
                                        let __field1 =
                                            match match _serde::de::SeqAccess::next_element::<ResourceMap>(&mut __seq)
                                                                    {
                                                                _serde::__private::Ok(__val) => __val,
                                                                _serde::__private::Err(__err) => {
                                                                    return _serde::__private::Err(__err);
                                                                }
                                                            } {
                                                    _serde::__private::Some(__value) => __value,
                                                    _serde::__private::None => {
                                                        return _serde::__private::Err(_serde::de::Error::invalid_length(1usize,
                                                                    &"struct Bundle with 2 elements"));
                                                    }
                                                };
                                        let __field2 = _serde::__private::Default::default();
                                        _serde::__private::Ok(Bundle{
                                                manifest: __field0,

                                                resources: __field1,

                                                root_dir: __field2,})
                                    }
                                #[inline]
                                fn visit_map<__A>(self: Self, mut __map: __A)
                                    -> _serde::__private::Result<Self::Value, __A::Error> where
                                    __A: _serde::de::MapAccess<'de> {
                                        let mut __field0: _serde::__private::Option<M> =
                                            _serde::__private::None;
                                        let mut __field1: _serde::__private::Option<ResourceMap> =
                                            _serde::__private::None;
                                        loop {
                                                if let _serde::__private::Some(__key) =
                                                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                                                        {
                                                                    _serde::__private::Ok(__val) => __val,
                                                                    _serde::__private::Err(__err) => {
                                                                        return _serde::__private::Err(__err);
                                                                    }
                                                                }
                                                        {
                                                                match __key {
                                                                        __Field::__field0 => {
                                                                            if _serde::__private::Option::is_some(&__field0)
                                                                                    {
                                                                                            return _serde::__private::Err(<__A::Error as
                                                                                                            _serde::de::Error>::duplicate_field("manifest"));
                                                                                        }
                                                                                    __field0 =
                                                                                        _serde::__private::Some(match _serde::de::MapAccess::next_value::<M>(&mut __map)
                                                                                                        {
                                                                                                    _serde::__private::Ok(__val) => __val,
                                                                                                    _serde::__private::Err(__err) => {
                                                                                                        return _serde::__private::Err(__err);
                                                                                                    }
                                                                                                });
                                                                                }
                                                                                __Field::__field1 => {
                                                                                    if _serde::__private::Option::is_some(&__field1)
                                                                                            {
                                                                                                    return _serde::__private::Err(<__A::Error as
                                                                                                                    _serde::de::Error>::duplicate_field("resources"));
                                                                                                }
                                                                                            __field1 =
                                                                                                _serde::__private::Some(match _serde::de::MapAccess::next_value::<ResourceMap>(&mut __map)
                                                                                                                {
                                                                                                            _serde::__private::Ok(__val) => __val,
                                                                                                            _serde::__private::Err(__err) => {
                                                                                                                return _serde::__private::Err(__err);
                                                                                                            }
                                                                                                        });
                                                                                        }
                                                                                        _ => {
                                                                                            let _ =
                                                                                                match _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)
                                                                                                            {
                                                                                                        _serde::__private::Ok(__val) => __val,
                                                                                                        _serde::__private::Err(__err) => {
                                                                                                            return _serde::__private::Err(__err);
                                                                                                        }
                                                                                                    };
                                                                                        } } } else { break; } }
                                                            let __field0 =
                                                                match __field0 {
                                                                        _serde::__private::Some(__field0) => __field0,
                                                                        _serde::__private::None =>
                                                                            match _serde::__private::de::missing_field("manifest") {
                                                                                    _serde::__private::Ok(__val) => __val,
                                                                                    _serde::__private::Err(__err) => {
                                                                                        return _serde::__private::Err(__err);
                                                                                    }
                                                                                },
                                                                    };
                                                            let __field1 =
                                                                match __field1 {
                                                                        _serde::__private::Some(__field1) => __field1,
                                                                        _serde::__private::None =>
                                                                            match _serde::__private::de::missing_field("resources") {
                                                                                    _serde::__private::Ok(__val) => __val,
                                                                                    _serde::__private::Err(__err) => {
                                                                                        return _serde::__private::Err(__err);
                                                                                    }
                                                                                },
                                                                    };
                                                            _serde::__private::Ok(Bundle{
                                                                    manifest: __field0,

                                                                    resources: __field1,

                                                                    root_dir: _serde::__private::Default::default(),}) }
                                                    }
                                                    #[doc(hidden)]
                                                    const FIELDS: &'static [&'static str] =
                                                        &["manifest", "resources"];
                                                    _serde::Deserializer::deserialize_struct(__deserializer,
                                                        "Bundle", FIELDS,
                                                        __Visitor{
                                                            marker: _serde::__private::PhantomData::<Bundle<M>>,

                                                            lifetime: _serde::__private::PhantomData,}) } }
                                    };
                            impl <M> Bundle<M> where M: Manifest {
                                /// Creates a bundle containing a manifest and a collection of resources to
                                /// be bundled together with the manifest.
                                ///
                                /// The paths paired with each resource must correspond to the set of
                                /// `Location::Bundle`s specified in the `Manifest::location()`, or else
                                /// this is not a valid bundle.
                                ///
                                /// A base directory must also be supplied so that relative paths can be
                                /// resolved into absolute ones.
                                fn new<R>(manifest: M, resources: R, root_dir: PathBuf)
                                    -> MrBundleResult<Self> where R: IntoIterator<Item =
                                    (PathBuf,
                                    ResourceBytes)> {
                                        Self::from_parts(manifest, resources, Some(root_dir))
                                    }
                                /// Create a bundle, asserting that all paths in the Manifest are absolute.
                                fn new_unchecked<R>(manifest: M, resources: R)
                                    -> MrBundleResult<Self> where R: IntoIterator<Item =
                                    (PathBuf,
                                    ResourceBytes)> {
                                        Self::from_parts(manifest, resources, None)
                                    }
                                fn from_parts<R>(manifest: M, resources: R,
                                    root_dir: Option<PathBuf>) -> MrBundleResult<Self> where
                                    R: IntoIterator<Item =
                                    (PathBuf,
                                    ResourceBytes)> {
                                        let resources: ResourceMap =
                                            resources.into_iter().collect();
                                        let manifest_paths: HashSet<_> =
                                            manifest.locations().into_iter().filter_map(|loc|
                                                        match loc {
                                                                Location::Bundled(path) => Some(path),
                                                                _ => None,
                                                            }).collect();
                                        {
                                                let _t =
                                                    match #[lang = "into_iter"](resources.iter()) {
                                                            mut iter =>
                                                                loop {
                                                                        match #[lang = "next"](&mut iter) {
                                                                                #[lang = "None"] {} => break,
                                                                                #[lang = "Some"] {  0: (resource_path, _) } => {
                                                                                    if !manifest_paths.contains(resource_path)
                                                                                            {
                                                                                                    return Err(BundleError::BundledPathNotInManifest(resource_path.clone()).into());
                                                                                                }
                                                                                        } }
                                                                            }, }; _t };
                                                let resources = resources.into_iter().collect();
                                                Ok(Self{ manifest,  resources,  root_dir,})
                                            }
                                        /// Accessor for the Manifest
                                        fn manifest<'_>(self: &'_ Self) -> &'_ M { &self.manifest }
                                        /// Return a new Bundle with an updated manifest, subject to the same
                                        /// validation constraints as creating a new Bundle from scratch.
                                        fn update_manifest(self: Self, manifest: M)
                                            ->
                                                MrBundleResult<Self> {
                                                Self::from_parts(manifest, self.resources, self.root_dir)
                                            }
                                        /// Load a Bundle into memory from a file
                                        async fn read_from_file<'_>(path: &'_ Path)
                                            ->
                                                /*impl Trait*/ move
                                            |mut _task_context: #[lang = "ResumeTy"]|
                                            {
                                                    let path = path;
                                                    {
                                                            let _t =
                                                                {
                                                                        Self::decode(&match #[lang = "branch"](match #[lang = "into_future"](ffs::read(path))
                                                                                                            {
                                                                                                        mut __awaitee =>
                                                                                                            loop {
                                                                                                                    match unsafe {
                                                                                                                                        #[lang = "poll"](#[lang = "new_unchecked"](&mut __awaitee),
                                                                                                                                            #[lang = "get_context"](_task_context))
                                                                                                                                    } {
                                                                                                                            #[lang = "Ready"] {  0: result } => break result,
                                                                                                                            #[lang = "Pending"] {} => { }
                                                                                                                        }
                                                                                                                    _task_context = (yield ());
                                                                                                                },
                                                                                                    }) {
                                                                                        #[lang = "Break"] {  0: residual } =>
                                                                                            #[allow(unreachable_code)]
                                                                                            return #[lang = "from_residual"](residual),
                                                                                        #[lang = "Continue"] {  0: val } =>
                                                                                            #[allow(unreachable_code)]
                                                                                            val,
                                                                                    })
                                                                    };
                                                            _t
                                                        }
                                                }
                                        /// Write a Bundle to a file
                                        async fn write_to_file<'_,
                                            '_>(self: &'_ Self, path: &'_ Path)
                                            ->
                                                /*impl Trait*/ move
                                            |mut _task_context: #[lang = "ResumeTy"]|
                                            {
                                                    let self = self;
                                                    let path = path;
                                                    {
                                                            let _t =
                                                                {
                                                                        Ok(match #[lang = "branch"](match #[lang = "into_future"](ffs::write(path,
                                                                                                                &match #[lang = "branch"](self.encode()) {
                                                                                                                            #[lang = "Break"] {  0: residual } =>
                                                                                                                                #[allow(unreachable_code)]
                                                                                                                                return #[lang = "from_residual"](residual),
                                                                                                                            #[lang = "Continue"] {  0: val } =>
                                                                                                                                #[allow(unreachable_code)]
                                                                                                                                val,
                                                                                                                        })) {
                                                                                                    mut __awaitee =>
                                                                                                        loop {
                                                                                                                match unsafe {
                                                                                                                                    #[lang = "poll"](#[lang = "new_unchecked"](&mut __awaitee),
                                                                                                                                        #[lang = "get_context"](_task_context))
                                                                                                                                } {
                                                                                                                        #[lang = "Ready"] {  0: result } => break result,
                                                                                                                        #[lang = "Pending"] {} => { }
                                                                                                                    }
                                                                                                                _task_context = (yield ());
                                                                                                            },
                                                                                                }) {
                                                                                    #[lang = "Break"] {  0: residual } =>
                                                                                        #[allow(unreachable_code)]
                                                                                        return #[lang = "from_residual"](residual),
                                                                                    #[lang = "Continue"] {  0: val } =>
                                                                                        #[allow(unreachable_code)]
                                                                                        val,
                                                                                })
                                                                    };
                                                            _t
                                                        }
                                                }
                                        /// Retrieve the bytes for a resource at a Location, downloading it if
                                        /// necessary
                                        async fn resolve<'_,
                                            '_>(self: &'_ Self, location: &'_ Location)
                                            ->
                                                /*impl Trait*/ move
                                            |mut _task_context: #[lang = "ResumeTy"]|
                                            {
                                                    let self = self;
                                                    let location = location;
                                                    {
                                                            let _t =
                                                                {
                                                                        let bytes =
                                                                            match &match #[lang = "branch"](location.normalize(self.root_dir.as_ref()))
                                                                                                        {
                                                                                                    #[lang = "Break"] {  0: residual } =>
                                                                                                        #[allow(unreachable_code)]
                                                                                                        return #[lang = "from_residual"](residual),
                                                                                                    #[lang = "Continue"] {  0: val } =>
                                                                                                        #[allow(unreachable_code)]
                                                                                                        val,
                                                                                                } {
                                                                                    Location::Bundled(path) =>
                                                                                        Cow::Borrowed(match #[lang = "branch"](self.resources.get(path).ok_or_else(||
                                                                                                                    BundleError::BundledResourceMissing(path.clone()))) {
                                                                                                    #[lang = "Break"] {  0: residual } =>
                                                                                                        #[allow(unreachable_code)]
                                                                                                        return #[lang = "from_residual"](residual),
                                                                                                    #[lang = "Continue"] {  0: val } =>
                                                                                                        #[allow(unreachable_code)]
                                                                                                        val,
                                                                                                }),
                                                                                    Location::Path(path) =>
                                                                                        Cow::Owned(match #[lang = "branch"](match #[lang = "into_future"](crate::location::resolve_local(path))
                                                                                                                        {
                                                                                                                    mut __awaitee =>
                                                                                                                        loop {
                                                                                                                                match unsafe {
                                                                                                                                                    #[lang = "poll"](#[lang = "new_unchecked"](&mut __awaitee),
                                                                                                                                                        #[lang = "get_context"](_task_context))
                                                                                                                                                } {
                                                                                                                                        #[lang = "Ready"] {  0: result } => break result,
                                                                                                                                        #[lang = "Pending"] {} => { }
                                                                                                                                    }
                                                                                                                                _task_context = (yield ());
                                                                                                                            },
                                                                                                                }) {
                                                                                                    #[lang = "Break"] {  0: residual } =>
                                                                                                        #[allow(unreachable_code)]
                                                                                                        return #[lang = "from_residual"](residual),
                                                                                                    #[lang = "Continue"] {  0: val } =>
                                                                                                        #[allow(unreachable_code)]
                                                                                                        val,
                                                                                                }),
                                                                                    Location::Url(url) =>
                                                                                        Cow::Owned(match #[lang = "branch"](match #[lang = "into_future"](crate::location::resolve_remote(url))
                                                                                                                        {
                                                                                                                    mut __awaitee =>
                                                                                                                        loop {
                                                                                                                                match unsafe {
                                                                                                                                                    #[lang = "poll"](#[lang = "new_unchecked"](&mut __awaitee),
                                                                                                                                                        #[lang = "get_context"](_task_context))
                                                                                                                                                } {
                                                                                                                                        #[lang = "Ready"] {  0: result } => break result,
                                                                                                                                        #[lang = "Pending"] {} => { }
                                                                                                                                    }
                                                                                                                                _task_context = (yield ());
                                                                                                                            },
                                                                                                                }) {
                                                                                                    #[lang = "Break"] {  0: residual } =>
                                                                                                        #[allow(unreachable_code)]
                                                                                                        return #[lang = "from_residual"](residual),
                                                                                                    #[lang = "Continue"] {  0: val } =>
                                                                                                        #[allow(unreachable_code)]
                                                                                                        val,
                                                                                                }),
                                                                                };
                                                                        Ok(bytes)
                                                                    };
                                                            _t
                                                        }
                                                }
                                        /// Return the full set of resources specified by this bundle's manifest.
                                        /// References to bundled resources can be returned directly, while all
                                        /// others will be fetched from the filesystem or the network.
                                        async fn resolve_all<'_>(self: &'_ Self)
                                            ->
                                                /*impl Trait*/ move
                                            |mut _task_context: #[lang = "ResumeTy"]|
                                            {
                                                    let self = self;
                                                    {
                                                            let _t =
                                                                {
                                                                        match #[lang = "into_future"](futures::future::join_all(self.manifest.locations().into_iter().map(|loc|
                                                                                                            move |mut _task_context: #[lang = "ResumeTy"]|
                                                                                                                {
                                                                                                                        MrBundleResult::Ok((loc.clone(),
                                                                                                                                match #[lang = "branch"](match #[lang = "into_future"](self.resolve(&loc))
                                                                                                                                                            {
                                                                                                                                                        mut __awaitee =>
                                                                                                                                                            loop {
                                                                                                                                                                    match unsafe {
                                                                                                                                                                                        #[lang = "poll"](#[lang = "new_unchecked"](&mut __awaitee),
                                                                                                                                                                                            #[lang = "get_context"](_task_context))
                                                                                                                                                                                    } {
                                                                                                                                                                            #[lang = "Ready"] {  0: result } => break result,
                                                                                                                                                                            #[lang = "Pending"] {} => { }
                                                                                                                                                                        }
                                                                                                                                                                    _task_context = (yield ());
                                                                                                                                                                },
                                                                                                                                                    }) {
                                                                                                                                        #[lang = "Break"] {  0: residual } =>
                                                                                                                                            #[allow(unreachable_code)]
                                                                                                                                            return #[lang = "from_residual"](residual),
                                                                                                                                        #[lang = "Continue"] {  0: val } =>
                                                                                                                                            #[allow(unreachable_code)]
                                                                                                                                            val,
                                                                                                                                    }))
                                                                                                                    }))) {
                                                                                        mut __awaitee =>
                                                                                            loop {
                                                                                                    match unsafe {
                                                                                                                        #[lang = "poll"](#[lang = "new_unchecked"](&mut __awaitee),
                                                                                                                            #[lang = "get_context"](_task_context))
                                                                                                                    } {
                                                                                                            #[lang = "Ready"] {  0: result } => break result,
                                                                                                            #[lang = "Pending"] {} => { }
                                                                                                        }
                                                                                                    _task_context = (yield ());
                                                                                                },
                                                                                    }.into_iter().collect::<MrBundleResult<HashMap<Location,
                                                                            Cow<, ResourceBytes>>>>()
                                                                    };
                                                            _t
                                                        }
                                                }
                                        /// Resolve all resources, but with fully owned references
                                        async fn resolve_all_cloned<'_>(self: &'_ Self)
                                            ->
                                                /*impl Trait*/ move
                                            |mut _task_context: #[lang = "ResumeTy"]|
                                            {
                                                    let self = self;
                                                    {
                                                            let _t =
                                                                {
                                                                        Ok(match #[lang = "branch"](match #[lang = "into_future"](self.resolve_all())
                                                                                                                    {
                                                                                                                mut __awaitee =>
                                                                                                                    loop {
                                                                                                                            match unsafe {
                                                                                                                                                #[lang = "poll"](#[lang = "new_unchecked"](&mut __awaitee),
                                                                                                                                                    #[lang = "get_context"](_task_context))
                                                                                                                                            } {
                                                                                                                                    #[lang = "Ready"] {  0: result } => break result,
                                                                                                                                    #[lang = "Pending"] {} => { }
                                                                                                                                }
                                                                                                                            _task_context = (yield ());
                                                                                                                        },
                                                                                                            }) {
                                                                                                #[lang = "Break"] {  0: residual } =>
                                                                                                    #[allow(unreachable_code)]
                                                                                                    return #[lang = "from_residual"](residual),
                                                                                                #[lang = "Continue"] {  0: val } =>
                                                                                                    #[allow(unreachable_code)]
                                                                                                    val,
                                                                                            }.into_iter().map(|(k, v)| (k, v.into_owned())).collect())
                                                                    };
                                                            _t
                                                        }
                                                }
                                        /// Access the map of resources included in this bundle
                                        /// Bundled resources are also accessible via `resolve` or `resolve_all`,
                                        /// but using this method prevents a Clone
                                        fn bundled_resources<'_>(self: &'_ Self)
                                            -> &'_ ResourceMap { &self.resources }
                                        /// An arbitrary and opaque encoding of the bundle data into a byte array
                                        fn encode<'_>(self: &'_ Self)
                                            -> MrBundleResult<Vec<u8>> { crate::encode(self) }
                                        /// Decode bytes produced by [`encode`](Bundle::encode)
                                        fn decode<'_>(bytes: &'_ [u8])
                                            -> MrBundleResult<Self> { crate::decode(bytes) }
                                    }
                                    /// A manifest bundled together, optionally, with the Resources that it describes.
                                    /// The manifest may be of any format. This is useful for deserializing a bundle of
                                    /// an outdated format, so that it may be modified to fit the supported format.
                                    struct RawBundle<M> {
                                        /// The manifest describing the resources that compose this bundle.
                                        #[serde(bound(deserialize = "M: DeserializeOwned"))]
                                        manifest: M,
                                        /// The full or partial resource data. Each entry must correspond to one
                                        /// of the Bundled Locations specified by the Manifest. Bundled Locations
                                        /// are always relative paths (relative to the root_dir).
                                        resources: ResourceMap,
                                    }
                                    #[automatically_derived]
                                    impl <M> ::core::fmt::Debug for RawBundle<M> where
                                        M: ::core::fmt::Debug {
                                        fn fmt<'_, '_,
                                            '_>(self: &'_ Self, f: &'_ mut ::core::fmt::Formatter<>)
                                            ->
                                                ::core::fmt::Result {
                                                ::core::fmt::Formatter::debug_struct_field2_finish(f,
                                                    "RawBundle", "manifest", &self.manifest, "resources",
                                                    &&self.resources)
                                            }
                                    }
                                    #[automatically_derived]
                                    impl <M> ::core::marker::StructuralPartialEq for
                                        RawBundle<M> {
                                    }
                                    #[automatically_derived]
                                    impl <M> ::core::cmp::PartialEq for RawBundle<M> where
                                        M: ::core::cmp::PartialEq {
                                        #[inline]
                                        fn eq<'_, '_>(self: &'_ Self, other: &'_ RawBundle<M>)
                                            ->
                                                bool {
                                                self.manifest == other.manifest &&
                                                    self.resources == other.resources
                                            }
                                    }
                                    #[automatically_derived]
                                    impl <M> ::core::marker::StructuralEq for RawBundle<M> { }
                                    #[automatically_derived]
                                    impl <M> ::core::cmp::Eq for RawBundle<M> where
                                        M: ::core::cmp::Eq {
                                        #[inline]
                                        #[doc(hidden)]
                                        #[no_coverage]
                                        fn assert_receiver_is_total_eq<'_>(self: &'_ Self)
                                            ->
                                                () {
                                                let _: ::core::cmp::AssertParamIsEq<M>;
                                                let _: ::core::cmp::AssertParamIsEq<ResourceMap>;
                                            }
                                    }
                                    #[doc(hidden)]
                                    #[allow(non_upper_case_globals, unused_attributes,
                                    unused_qualifications)]
                                    const _: () =
                                        {
                                                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                                                extern crate serde as _serde;
                                                #[allow(unused_macros)]
                                                macro_rules! try {
                                                    ($__expr : expr) =>
                                                    {
                                                        match $__expr
                                                        {
                                                            _serde :: __private :: Ok(__val) => __val, _serde ::
                                                            __private :: Err(__err) =>
                                                            { return _serde :: __private :: Err(__err) ; }
                                                        }
                                                    }
                                                }
                                                #[automatically_derived]
                                                impl <'de, M> _serde::Deserialize<'de> for RawBundle<M>
                                                    where M: DeserializeOwned {
                                                    fn deserialize<__D>(__deserializer: __D)
                                                        -> _serde::__private::Result<Self, __D::Error> where
                                                        __D: _serde::Deserializer<'de> {
                                                            #[allow(non_camel_case_types)]
                                                            #[doc(hidden)]
                                                            enum __Field { __field0, __field1, __ignore, }
                                                            #[doc(hidden)]
                                                            struct __FieldVisitor;
                                                            impl <'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                                                type
                                                                Value
                                                                =
                                                                __Field;
                                                                fn expecting<'_, '_,
                                                                    '_>(self: &'_ Self,
                                                                    __formatter: &'_ mut _serde::__private::Formatter<>)
                                                                    ->
                                                                        _serde::__private::fmt::Result {
                                                                        _serde::__private::Formatter::write_str(__formatter,
                                                                            "field identifier")
                                                                    }
                                                                fn visit_u64<__E>(self: Self, __value: u64)
                                                                    -> _serde::__private::Result<Self::Value, __E> where
                                                                    __E: _serde::de::Error {
                                                                        match __value {
                                                                                0u64 => _serde::__private::Ok(__Field::__field0),
                                                                                1u64 => _serde::__private::Ok(__Field::__field1),
                                                                                _ => _serde::__private::Ok(__Field::__ignore),
                                                                            }
                                                                    }
                                                                fn visit_str<__E, '_>(self: Self, __value: &'_ str)
                                                                    -> _serde::__private::Result<Self::Value, __E> where
                                                                    __E: _serde::de::Error {
                                                                        match __value {
                                                                                "manifest" => _serde::__private::Ok(__Field::__field0),
                                                                                "resources" => _serde::__private::Ok(__Field::__field1),
                                                                                _ => { _serde::__private::Ok(__Field::__ignore) }
                                                                            }
                                                                    }
                                                                fn visit_bytes<__E, '_>(self: Self, __value: &'_ [u8])
                                                                    -> _serde::__private::Result<Self::Value, __E> where
                                                                    __E: _serde::de::Error {
                                                                        match __value {
                                                                                b"manifest" => _serde::__private::Ok(__Field::__field0),
                                                                                b"resources" => _serde::__private::Ok(__Field::__field1),
                                                                                _ => { _serde::__private::Ok(__Field::__ignore) }
                                                                            }
                                                                    }
                                                            }
                                                            impl <'de> _serde::Deserialize<'de> for __Field {
                                                                #[inline]
                                                                fn deserialize<__D>(__deserializer: __D)
                                                                    -> _serde::__private::Result<Self, __D::Error> where
                                                                    __D: _serde::Deserializer<'de> {
                                                                        _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                            __FieldVisitor)
                                                                    }
                                                            }
                                                            #[doc(hidden)]
                                                            struct __Visitor<'de, M> where M: DeserializeOwned {
                                                                marker: _serde::__private::PhantomData<RawBundle<M>>,
                                                                lifetime: _serde::__private::PhantomData<&'de ()>,
                                                            }
                                                            impl <'de, M> _serde::de::Visitor<'de> for __Visitor<'de, M>
                                                                where M: DeserializeOwned {
                                                                type
                                                                Value
                                                                =
                                                                RawBundle<M>;
                                                                fn expecting<'_, '_,
                                                                    '_>(self: &'_ Self,
                                                                    __formatter: &'_ mut _serde::__private::Formatter<>)
                                                                    ->
                                                                        _serde::__private::fmt::Result {
                                                                        _serde::__private::Formatter::write_str(__formatter,
                                                                            "struct RawBundle")
                                                                    }
                                                                #[inline]
                                                                fn visit_seq<__A>(self: Self, mut __seq: __A)
                                                                    -> _serde::__private::Result<Self::Value, __A::Error> where
                                                                    __A: _serde::de::SeqAccess<'de> {
                                                                        let __field0 =
                                                                            match match _serde::de::SeqAccess::next_element::<M>(&mut __seq)
                                                                                                    {
                                                                                                _serde::__private::Ok(__val) => __val,
                                                                                                _serde::__private::Err(__err) => {
                                                                                                    return _serde::__private::Err(__err);
                                                                                                }
                                                                                            } {
                                                                                    _serde::__private::Some(__value) => __value,
                                                                                    _serde::__private::None => {
                                                                                        return _serde::__private::Err(_serde::de::Error::invalid_length(0usize,
                                                                                                    &"struct RawBundle with 2 elements"));
                                                                                    }
                                                                                };
                                                                        let __field1 =
                                                                            match match _serde::de::SeqAccess::next_element::<ResourceMap>(&mut __seq)
                                                                                                    {
                                                                                                _serde::__private::Ok(__val) => __val,
                                                                                                _serde::__private::Err(__err) => {
                                                                                                    return _serde::__private::Err(__err);
                                                                                                }
                                                                                            } {
                                                                                    _serde::__private::Some(__value) => __value,
                                                                                    _serde::__private::None => {
                                                                                        return _serde::__private::Err(_serde::de::Error::invalid_length(1usize,
                                                                                                    &"struct RawBundle with 2 elements"));
                                                                                    }
                                                                                };
                                                                        _serde::__private::Ok(RawBundle{
                                                                                manifest: __field0,

                                                                                resources: __field1,})
                                                                    }
                                                                #[inline]
                                                                fn visit_map<__A>(self: Self, mut __map: __A)
                                                                    -> _serde::__private::Result<Self::Value, __A::Error> where
                                                                    __A: _serde::de::MapAccess<'de> {
                                                                        let mut __field0: _serde::__private::Option<M> =
                                                                            _serde::__private::None;
                                                                        let mut __field1: _serde::__private::Option<ResourceMap> =
                                                                            _serde::__private::None;
                                                                        loop {
                                                                                if let _serde::__private::Some(__key) =
                                                                                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                                                                                        {
                                                                                                    _serde::__private::Ok(__val) => __val,
                                                                                                    _serde::__private::Err(__err) => {
                                                                                                        return _serde::__private::Err(__err);
                                                                                                    }
                                                                                                }
                                                                                        {
                                                                                                match __key {
                                                                                                        __Field::__field0 => {
                                                                                                            if _serde::__private::Option::is_some(&__field0)
                                                                                                                    {
                                                                                                                            return _serde::__private::Err(<__A::Error as
                                                                                                                                            _serde::de::Error>::duplicate_field("manifest"));
                                                                                                                        }
                                                                                                                    __field0 =
                                                                                                                        _serde::__private::Some(match _serde::de::MapAccess::next_value::<M>(&mut __map)
                                                                                                                                        {
                                                                                                                                    _serde::__private::Ok(__val) => __val,
                                                                                                                                    _serde::__private::Err(__err) => {
                                                                                                                                        return _serde::__private::Err(__err);
                                                                                                                                    }
                                                                                                                                });
                                                                                                                }
                                                                                                                __Field::__field1 => {
                                                                                                                    if _serde::__private::Option::is_some(&__field1)
                                                                                                                            {
                                                                                                                                    return _serde::__private::Err(<__A::Error as
                                                                                                                                                    _serde::de::Error>::duplicate_field("resources"));
                                                                                                                                }
                                                                                                                            __field1 =
                                                                                                                                _serde::__private::Some(match _serde::de::MapAccess::next_value::<ResourceMap>(&mut __map)
                                                                                                                                                {
                                                                                                                                            _serde::__private::Ok(__val) => __val,
                                                                                                                                            _serde::__private::Err(__err) => {
                                                                                                                                                return _serde::__private::Err(__err);
                                                                                                                                            }
                                                                                                                                        });
                                                                                                                        }
                                                                                                                        _ => {
                                                                                                                            let _ =
                                                                                                                                match _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)
                                                                                                                                            {
                                                                                                                                        _serde::__private::Ok(__val) => __val,
                                                                                                                                        _serde::__private::Err(__err) => {
                                                                                                                                            return _serde::__private::Err(__err);
                                                                                                                                        }
                                                                                                                                    };
                                                                                                                        } } } else { break; } }
                                                                                            let __field0 =
                                                                                                match __field0 {
                                                                                                        _serde::__private::Some(__field0) => __field0,
                                                                                                        _serde::__private::None =>
                                                                                                            match _serde::__private::de::missing_field("manifest") {
                                                                                                                    _serde::__private::Ok(__val) => __val,
                                                                                                                    _serde::__private::Err(__err) => {
                                                                                                                        return _serde::__private::Err(__err);
                                                                                                                    }
                                                                                                                },
                                                                                                    };
                                                                                            let __field1 =
                                                                                                match __field1 {
                                                                                                        _serde::__private::Some(__field1) => __field1,
                                                                                                        _serde::__private::None =>
                                                                                                            match _serde::__private::de::missing_field("resources") {
                                                                                                                    _serde::__private::Ok(__val) => __val,
                                                                                                                    _serde::__private::Err(__err) => {
                                                                                                                        return _serde::__private::Err(__err);
                                                                                                                    }
                                                                                                                },
                                                                                                    };
                                                                                            _serde::__private::Ok(RawBundle{
                                                                                                    manifest: __field0,

                                                                                                    resources: __field1,}) }
                                                                                    }
                                                                                    #[doc(hidden)]
                                                                                    const FIELDS: &'static [&'static str] =
                                                                                        &["manifest", "resources"];
                                                                                    _serde::Deserializer::deserialize_struct(__deserializer,
                                                                                        "RawBundle", FIELDS,
                                                                                        __Visitor{
                                                                                            marker: _serde::__private::PhantomData::<RawBundle<M>>,

                                                                                            lifetime: _serde::__private::PhantomData,}) } }
                                                                    };
                                                            impl <M> RawBundle<M> where M: serde::de::DeserializeOwned {
                                                                /// Load a Bundle into memory from a file
                                                                async fn read_from_file<'_>(path: &'_ Path)
                                                                    ->
                                                                        /*impl Trait*/ move
                                                                    |mut _task_context: #[lang = "ResumeTy"]|
                                                                    {
                                                                            let path = path;
                                                                            {
                                                                                    let _t =
                                                                                        {
                                                                                                crate::decode(&match #[lang = "branch"](match #[lang = "into_future"](ffs::read(path))
                                                                                                                                    {
                                                                                                                                mut __awaitee =>
                                                                                                                                    loop {
                                                                                                                                            match unsafe {
                                                                                                                                                                #[lang = "poll"](#[lang = "new_unchecked"](&mut __awaitee),
                                                                                                                                                                    #[lang = "get_context"](_task_context))
                                                                                                                                                            } {
                                                                                                                                                    #[lang = "Ready"] {  0: result } => break result,
                                                                                                                                                    #[lang = "Pending"] {} => { }
                                                                                                                                                }
                                                                                                                                            _task_context = (yield ());
                                                                                                                                        },
                                                                                                                            }) {
                                                                                                                #[lang = "Break"] {  0: residual } =>
                                                                                                                    #[allow(unreachable_code)]
                                                                                                                    return #[lang = "from_residual"](residual),
                                                                                                                #[lang = "Continue"] {  0: val } =>
                                                                                                                    #[allow(unreachable_code)]
                                                                                                                    val,
                                                                                                            })
                                                                                            };
                                                                                    _t
                                                                                }
                                                                        }
                                                            }
                                                        }
                                                        mod encoding {
                                                            use super::error::MrBundleResult;
                                                            use std::io::Read;
                                                            use std::io::Write;
                                                            /// Get compressed bytes from some serializable data
                                                            fn encode<T, '_>(data: &'_ T) -> MrBundleResult<Vec<u8>>
                                                                where
                                                                T: serde::ser::Serialize {
                                                                    let bytes =
                                                                        match #[lang = "branch"](rmp_serde::to_vec_named(data)) {
                                                                                #[lang = "Break"] {  0: residual } =>
                                                                                    #[allow(unreachable_code)]
                                                                                    return #[lang = "from_residual"](residual),
                                                                                #[lang = "Continue"] {  0: val } =>
                                                                                    #[allow(unreachable_code)]
                                                                                    val,
                                                                            };
                                                                    let mut enc =
                                                                        flate2::write::GzEncoder::new(Vec::new(),
                                                                            flate2::Compression::default());
                                                                    match #[lang = "branch"](enc.write_all(&bytes)) {
                                                                            #[lang = "Break"] {  0: residual } =>
                                                                                #[allow(unreachable_code)]
                                                                                return #[lang = "from_residual"](residual),
                                                                            #[lang = "Continue"] {  0: val } =>
                                                                                #[allow(unreachable_code)]
                                                                                val,
                                                                        };
                                                                    Ok(match #[lang = "branch"](enc.finish()) {
                                                                                #[lang = "Break"] {  0: residual } =>
                                                                                    #[allow(unreachable_code)]
                                                                                    return #[lang = "from_residual"](residual),
                                                                                #[lang = "Continue"] {  0: val } =>
                                                                                    #[allow(unreachable_code)]
                                                                                    val,
                                                                            })
                                                                }
                                                            /// Decompress and deserialize some bytes (inverse of `encode`)
                                                            fn decode<T, '_>(compressed: &'_ [u8]) -> MrBundleResult<T>
                                                                where
                                                                T: serde::de::DeserializeOwned {
                                                                    let mut gz = flate2::read::GzDecoder::new(compressed);
                                                                    let mut bytes = Vec::new();
                                                                    match #[lang = "branch"](gz.read_to_end(&mut bytes)) {
                                                                            #[lang = "Break"] {  0: residual } =>
                                                                                #[allow(unreachable_code)]
                                                                                return #[lang = "from_residual"](residual),
                                                                            #[lang = "Continue"] {  0: val } =>
                                                                                #[allow(unreachable_code)]
                                                                                val,
                                                                        };
                                                                    Ok(match #[lang = "branch"](rmp_serde::from_read_ref(&bytes))
                                                                                    {
                                                                                #[lang = "Break"] {  0: residual } =>
                                                                                    #[allow(unreachable_code)]
                                                                                    return #[lang = "from_residual"](residual),
                                                                                #[lang = "Continue"] {  0: val } =>
                                                                                    #[allow(unreachable_code)]
                                                                                    val,
                                                                            })
                                                                }
                                                        }
                                                        mod error {
                                                            #![allow(missing_docs)]
                                                            use holochain_util::ffs::IoError;
                                                            /// Any error which can occur in this crate
                                                            enum MrBundleError {

                                                                #[error(transparent)]
                                                                StdIoError(
                                                                        #[from]
                                                                        std::io::Error),

                                                                #[error(transparent)]
                                                                BundleError(
                                                                        #[from]
                                                                        BundleError),

                                                                #[error("IO error: {0}")]
                                                                IoError(
                                                                        #[from]
                                                                        IoError),

                                                                #[error(transparent)]
                                                                HttpError(
                                                                        #[from]
                                                                        reqwest::Error),

                                                                #[error(transparent)]
                                                                MsgpackEncodeError(
                                                                        #[from]
                                                                        rmp_serde::encode::Error),

                                                                #[error(transparent)]
                                                                MsgpackDecodeError(
                                                                        #[from]
                                                                        rmp_serde::decode::Error),

                                                                #[error("This bundle failed to validate because: {0}")]
                                                                BundleValidationError(String),
                                                            }
                                                            #[automatically_derived]
                                                            impl ::core::fmt::Debug for MrBundleError {
                                                                fn fmt<'_, '_,
                                                                    '_>(self: &'_ Self, f: &'_ mut ::core::fmt::Formatter<>)
                                                                    ->
                                                                        ::core::fmt::Result {
                                                                        match self {
                                                                                MrBundleError::StdIoError(__self_0) =>
                                                                                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                                                                                        "StdIoError", &__self_0),
                                                                                MrBundleError::BundleError(__self_0) =>
                                                                                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                                                                                        "BundleError", &__self_0),
                                                                                MrBundleError::IoError(__self_0) =>
                                                                                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                                                                                        "IoError", &__self_0),
                                                                                MrBundleError::HttpError(__self_0) =>
                                                                                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                                                                                        "HttpError", &__self_0),
                                                                                MrBundleError::MsgpackEncodeError(__self_0) =>
                                                                                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                                                                                        "MsgpackEncodeError", &__self_0),
                                                                                MrBundleError::MsgpackDecodeError(__self_0) =>
                                                                                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                                                                                        "MsgpackDecodeError", &__self_0),
                                                                                MrBundleError::BundleValidationError(__self_0) =>
                                                                                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                                                                                        "BundleValidationError", &__self_0),
                                                                            }
                                                                    }
                                                            }
                                                            #[allow(unused_qualifications)]
                                                            impl std::error::Error for MrBundleError {
                                                                fn source<'_>(self: &'_ Self)
                                                                    ->
                                                                        std::option::Option<&'_ dyn std::error::Error +
                                                                        'static> {
                                                                        use thiserror::__private::AsDynError;

                                                                        #[allow(deprecated)]
                                                                        match self {
                                                                                MrBundleError::StdIoError {  0: transparent } =>
                                                                                    std::error::Error::source(transparent.as_dyn_error()),
                                                                                MrBundleError::BundleError {  0: transparent } =>
                                                                                    std::error::Error::source(transparent.as_dyn_error()),
                                                                                MrBundleError::IoError {  0: source, .. } =>
                                                                                    std::option::Option::Some(source.as_dyn_error()),
                                                                                MrBundleError::HttpError {  0: transparent } =>
                                                                                    std::error::Error::source(transparent.as_dyn_error()),
                                                                                MrBundleError::MsgpackEncodeError {  0: transparent } =>
                                                                                    std::error::Error::source(transparent.as_dyn_error()),
                                                                                MrBundleError::MsgpackDecodeError {  0: transparent } =>
                                                                                    std::error::Error::source(transparent.as_dyn_error()),
                                                                                MrBundleError::BundleValidationError { .. } =>
                                                                                    std::option::Option::None,
                                                                            }
                                                                    }
                                                            }
                                                            #[allow(unused_qualifications)]
                                                            impl std::fmt::Display for MrBundleError {
                                                                fn fmt<'_, '_,
                                                                    '_>(self: &'_ Self,
                                                                    __formatter: &'_ mut std::fmt::Formatter<>)
                                                                    ->
                                                                        std::fmt::Result {
                                                                        #[allow(unused_imports)]
                                                                        use thiserror::__private::{};
                                                                        #[allow(unused_imports)]
                                                                        use thiserror::__private::DisplayAsDisplay;
                                                                        #[allow(unused_imports)]
                                                                        use thiserror::__private::PathAsDisplay;

                                                                        #[allow(unused_variables, deprecated, clippy ::
                                                                        used_underscore_binding)]
                                                                        match self {
                                                                                MrBundleError::StdIoError(_0) =>
                                                                                    std::fmt::Display::fmt(_0, __formatter),
                                                                                MrBundleError::BundleError(_0) =>
                                                                                    std::fmt::Display::fmt(_0, __formatter),
                                                                                MrBundleError::IoError(_0) =>
                                                                                    __formatter.write_fmt(<#[lang = "format_arguments"]>::new_v1(&["IO error: "],
                                                                                            &[<#[lang = "format_argument"]>::new_display(&_0.as_display())])),
                                                                                MrBundleError::HttpError(_0) =>
                                                                                    std::fmt::Display::fmt(_0, __formatter),
                                                                                MrBundleError::MsgpackEncodeError(_0) =>
                                                                                    std::fmt::Display::fmt(_0, __formatter),
                                                                                MrBundleError::MsgpackDecodeError(_0) =>
                                                                                    std::fmt::Display::fmt(_0, __formatter),
                                                                                MrBundleError::BundleValidationError(_0) =>
                                                                                    __formatter.write_fmt(<#[lang = "format_arguments"]>::new_v1(&["This bundle failed to validate because: "],
                                                                                            &[<#[lang = "format_argument"]>::new_display(&_0.as_display())])),
                                                                            }
                                                                    }
                                                            }
                                                            #[allow(unused_qualifications)]
                                                            impl std::convert::From<std::io::Error> for MrBundleError {
                                                                #[allow(deprecated)]
                                                                fn from(source: std::io::Error)
                                                                    -> Self { MrBundleError::StdIoError{ 0: source,} }
                                                            }
                                                            #[allow(unused_qualifications)]
                                                            impl std::convert::From<BundleError> for MrBundleError {
                                                                #[allow(deprecated)]
                                                                fn from(source: BundleError)
                                                                    -> Self { MrBundleError::BundleError{ 0: source,} }
                                                            }
                                                            #[allow(unused_qualifications)]
                                                            impl std::convert::From<IoError> for MrBundleError {
                                                                #[allow(deprecated)]
                                                                fn from(source: IoError)
                                                                    -> Self { MrBundleError::IoError{ 0: source,} }
                                                            }
                                                            #[allow(unused_qualifications)]
                                                            impl std::convert::From<reqwest::Error> for MrBundleError {
                                                                #[allow(deprecated)]
                                                                fn from(source: reqwest::Error)
                                                                    -> Self { MrBundleError::HttpError{ 0: source,} }
                                                            }
                                                            #[allow(unused_qualifications)]
                                                            impl std::convert::From<rmp_serde::encode::Error> for
                                                                MrBundleError {
                                                                #[allow(deprecated)]
                                                                fn from(source: rmp_serde::encode::Error)
                                                                    -> Self { MrBundleError::MsgpackEncodeError{ 0: source,} }
                                                            }
                                                            #[allow(unused_qualifications)]
                                                            impl std::convert::From<rmp_serde::decode::Error> for
                                                                MrBundleError {
                                                                #[allow(deprecated)]
                                                                fn from(source: rmp_serde::decode::Error)
                                                                    -> Self { MrBundleError::MsgpackDecodeError{ 0: source,} }
                                                            }
                                                            type MrBundleResult<T> = Result<T, MrBundleError>;
                                                            /// Errors which can occur while constructing a Bundle
                                                            enum BundleError {

                                                                #[error("The bundled resource path '{0}' is not mentioned in the manifest.
        Make sure that Manifest::location returns this path as a Location::Bundled.")]
                                                                BundledPathNotInManifest(std::path::PathBuf),

                                                                #[error("Attempted to resolve a bundled resource not present in this bundle: {0}")]
                                                                BundledResourceMissing(std::path::PathBuf),

                                                                #[error("Cannot use relative paths for local locations. The following local path is relative: {0}")]
                                                                RelativeLocalPath(std::path::PathBuf),
                                                            }
                                                            #[automatically_derived]
                                                            impl ::core::fmt::Debug for BundleError {
                                                                fn fmt<'_, '_,
                                                                    '_>(self: &'_ Self, f: &'_ mut ::core::fmt::Formatter<>)
                                                                    ->
                                                                        ::core::fmt::Result {
                                                                        match self {
                                                                                BundleError::BundledPathNotInManifest(__self_0) =>
                                                                                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                                                                                        "BundledPathNotInManifest", &__self_0),
                                                                                BundleError::BundledResourceMissing(__self_0) =>
                                                                                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                                                                                        "BundledResourceMissing", &__self_0),
                                                                                BundleError::RelativeLocalPath(__self_0) =>
                                                                                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                                                                                        "RelativeLocalPath", &__self_0),
                                                                            }
                                                                    }
                                                            }
                                                            #[automatically_derived]
                                                            impl ::core::marker::StructuralPartialEq for BundleError { }
                                                            #[automatically_derived]
                                                            impl ::core::cmp::PartialEq for BundleError {
                                                                #[inline]
                                                                fn eq<'_, '_>(self: &'_ Self, other: &'_ BundleError)
                                                                    ->
                                                                        bool {
                                                                        let __self_tag =
                                                                            ::core::intrinsics::discriminant_value(self);
                                                                        let __arg1_tag =
                                                                            ::core::intrinsics::discriminant_value(other);
                                                                        __self_tag == __arg1_tag &&
                                                                            match (self, other) {
                                                                                    (BundleError::BundledPathNotInManifest(__self_0),
                                                                                        BundleError::BundledPathNotInManifest(__arg1_0)) =>
                                                                                        *__self_0 == *__arg1_0,
                                                                                    (BundleError::BundledResourceMissing(__self_0),
                                                                                        BundleError::BundledResourceMissing(__arg1_0)) =>
                                                                                        *__self_0 == *__arg1_0,
                                                                                    (BundleError::RelativeLocalPath(__self_0),
                                                                                        BundleError::RelativeLocalPath(__arg1_0)) =>
                                                                                        *__self_0 == *__arg1_0,
                                                                                    _ => unsafe { ::core::intrinsics::unreachable() }
                                                                                }
                                                                    }
                                                            }
                                                            #[automatically_derived]
                                                            impl ::core::marker::StructuralEq for BundleError { }
                                                            #[automatically_derived]
                                                            impl ::core::cmp::Eq for BundleError {
                                                                #[inline]
                                                                #[doc(hidden)]
                                                                #[no_coverage]
                                                                fn assert_receiver_is_total_eq<'_>(self: &'_ Self)
                                                                    ->
                                                                        () {
                                                                        let _: ::core::cmp::AssertParamIsEq<std::path::PathBuf>;
                                                                        let _: ::core::cmp::AssertParamIsEq<std::path::PathBuf>;
                                                                        let _: ::core::cmp::AssertParamIsEq<std::path::PathBuf>;
                                                                    }
                                                            }
                                                            #[allow(unused_qualifications)]
                                                            impl std::error::Error for BundleError { }
                                                            #[allow(unused_qualifications)]
                                                            impl std::fmt::Display for BundleError {
                                                                fn fmt<'_, '_,
                                                                    '_>(self: &'_ Self,
                                                                    __formatter: &'_ mut std::fmt::Formatter<>)
                                                                    ->
                                                                        std::fmt::Result {
                                                                        #[allow(unused_imports)]
                                                                        use thiserror::__private::{};
                                                                        #[allow(unused_imports)]
                                                                        use thiserror::__private::DisplayAsDisplay;
                                                                        #[allow(unused_imports)]
                                                                        use thiserror::__private::PathAsDisplay;

                                                                        #[allow(unused_variables, deprecated, clippy ::
                                                                        used_underscore_binding)]
                                                                        match self {
                                                                                BundleError::BundledPathNotInManifest(_0) =>
                                                                                    __formatter.write_fmt(<#[lang = "format_arguments"]>::new_v1(&["The bundled resource path \'",
                                                                                                        "\' is not mentioned in the manifest.\n        Make sure that Manifest::location returns this path as a Location::Bundled."],
                                                                                            &[<#[lang = "format_argument"]>::new_display(&_0.as_display())])),
                                                                                BundleError::BundledResourceMissing(_0) =>
                                                                                    __formatter.write_fmt(<#[lang = "format_arguments"]>::new_v1(&["Attempted to resolve a bundled resource not present in this bundle: "],
                                                                                            &[<#[lang = "format_argument"]>::new_display(&_0.as_display())])),
                                                                                BundleError::RelativeLocalPath(_0) =>
                                                                                    __formatter.write_fmt(<#[lang = "format_arguments"]>::new_v1(&["Cannot use relative paths for local locations. The following local path is relative: "],
                                                                                            &[<#[lang = "format_argument"]>::new_display(&_0.as_display())])),
                                                                            }
                                                                    }
                                                            }
                                                            type BundleResult<T> = Result<T, BundleError>;
                                                        }
                                                        mod location {
                                                            use crate::{};
                                                            use crate::error::{};
                                                            use crate::error::BundleError;
                                                            use crate::error::MrBundleResult;
                                                            use crate::ResourceBytes;
                                                            use holochain_util::ffs;
                                                            use std::path::{};
                                                            use std::path::Path;
                                                            use std::path::PathBuf;
                                                            /// Where to find a Resource.
                                                            ///
                                                            /// This representation, with named fields, is chosen so that in the yaml config
                                                            /// either "path", "url", or "bundled" can be specified due to this field
                                                            /// being flattened.
                                                            #[serde(rename_all = "snake_case")]
                                                            #[allow(missing_docs)]
                                                            enum Location {

                                                                /// Expect file to be part of this bundle
                                                                Bundled(PathBuf),

                                                                /// Get file from local filesystem (not bundled)
                                                                Path(PathBuf),

                                                                /// Get file from URL
                                                                Url(String),
                                                            }
                                                            #[automatically_derived]
                                                            #[allow(missing_docs)]
                                                            impl ::core::clone::Clone for Location {
                                                                #[inline]
                                                                fn clone<'_>(self: &'_ Self)
                                                                    ->
                                                                        Location {
                                                                        match self {
                                                                                Location::Bundled(__self_0) =>
                                                                                    Location::Bundled(::core::clone::Clone::clone(__self_0)),
                                                                                Location::Path(__self_0) =>
                                                                                    Location::Path(::core::clone::Clone::clone(__self_0)),
                                                                                Location::Url(__self_0) =>
                                                                                    Location::Url(::core::clone::Clone::clone(__self_0)),
                                                                            }
                                                                    }
                                                            }
                                                            #[automatically_derived]
                                                            #[allow(missing_docs)]
                                                            impl ::core::fmt::Debug for Location {
                                                                fn fmt<'_, '_,
                                                                    '_>(self: &'_ Self, f: &'_ mut ::core::fmt::Formatter<>)
                                                                    ->
                                                                        ::core::fmt::Result {
                                                                        match self {
                                                                                Location::Bundled(__self_0) =>
                                                                                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                                                                                        "Bundled", &__self_0),
                                                                                Location::Path(__self_0) =>
                                                                                    ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Path",
                                                                                        &__self_0),
                                                                                Location::Url(__self_0) =>
                                                                                    ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Url",
                                                                                        &__self_0),
                                                                            }
                                                                    }
                                                            }
                                                            #[automatically_derived]
                                                            #[allow(missing_docs)]
                                                            impl ::core::hash::Hash for Location {
                                                                fn hash<__H, '_, '_>(self: &'_ Self, state: &'_ mut __H)
                                                                    -> () where
                                                                    __H: ::core::hash::Hasher {
                                                                        let __self_tag =
                                                                            ::core::intrinsics::discriminant_value(self);
                                                                        ::core::hash::Hash::hash(&__self_tag, state);
                                                                        match self {
                                                                                Location::Bundled(__self_0) =>
                                                                                    ::core::hash::Hash::hash(__self_0, state),
                                                                                Location::Path(__self_0) =>
                                                                                    ::core::hash::Hash::hash(__self_0, state),
                                                                                Location::Url(__self_0) =>
                                                                                    ::core::hash::Hash::hash(__self_0, state),
                                                                            }
                                                                    }
                                                            }
                                                            #[allow(missing_docs)]
                                                            #[automatically_derived]
                                                            impl ::core::marker::StructuralPartialEq for Location { }
                                                            #[automatically_derived]
                                                            #[allow(missing_docs)]
                                                            impl ::core::cmp::PartialEq for Location {
                                                                #[inline]
                                                                fn eq<'_, '_>(self: &'_ Self, other: &'_ Location)
                                                                    ->
                                                                        bool {
                                                                        let __self_tag =
                                                                            ::core::intrinsics::discriminant_value(self);
                                                                        let __arg1_tag =
                                                                            ::core::intrinsics::discriminant_value(other);
                                                                        __self_tag == __arg1_tag &&
                                                                            match (self, other) {
                                                                                    (Location::Bundled(__self_0), Location::Bundled(__arg1_0))
                                                                                        => *__self_0 == *__arg1_0,
                                                                                    (Location::Path(__self_0), Location::Path(__arg1_0)) =>
                                                                                        *__self_0 == *__arg1_0,
                                                                                    (Location::Url(__self_0), Location::Url(__arg1_0)) =>
                                                                                        *__self_0 == *__arg1_0,
                                                                                    _ => unsafe { ::core::intrinsics::unreachable() }
                                                                                }
                                                                    }
                                                            }
                                                            #[allow(missing_docs)]
                                                            #[automatically_derived]
                                                            impl ::core::marker::StructuralEq for Location { }
                                                            #[automatically_derived]
                                                            #[allow(missing_docs)]
                                                            impl ::core::cmp::Eq for Location {
                                                                #[inline]
                                                                #[doc(hidden)]
                                                                #[no_coverage]
                                                                fn assert_receiver_is_total_eq<'_>(self: &'_ Self)
                                                                    ->
                                                                        () {
                                                                        let _: ::core::cmp::AssertParamIsEq<PathBuf>;
                                                                        let _: ::core::cmp::AssertParamIsEq<String>;
                                                                    }
                                                            }
                                                            #[doc(hidden)]
                                                            #[allow(non_upper_case_globals, unused_attributes,
                                                            unused_qualifications)]
                                                            const _: () =
                                                                {
                                                                        #[allow(unused_extern_crates, clippy :: useless_attribute)]
                                                                        extern crate serde as _serde;
                                                                        #[allow(unused_macros)]
                                                                        macro_rules! try {
                                                                            ($__expr : expr) =>
                                                                            {
                                                                                match $__expr
                                                                                {
                                                                                    _serde :: __private :: Ok(__val) => __val, _serde ::
                                                                                    __private :: Err(__err) =>
                                                                                    { return _serde :: __private :: Err(__err) ; }
                                                                                }
                                                                            }
                                                                        }
                                                                        #[automatically_derived]
                                                                        impl _serde::Serialize for Location {
                                                                            fn serialize<__S, '_>(self: &'_ Self, __serializer: __S)
                                                                                -> _serde::__private::Result<__S::Ok, __S::Error> where
                                                                                __S: _serde::Serializer {
                                                                                    match *self {
                                                                                            Location::Bundled(ref __field0) =>
                                                                                                _serde::Serializer::serialize_newtype_variant(__serializer,
                                                                                                    "Location", 0u32, "bundled", __field0),
                                                                                            Location::Path(ref __field0) =>
                                                                                                _serde::Serializer::serialize_newtype_variant(__serializer,
                                                                                                    "Location", 1u32, "path", __field0),
                                                                                            Location::Url(ref __field0) =>
                                                                                                _serde::Serializer::serialize_newtype_variant(__serializer,
                                                                                                    "Location", 2u32, "url", __field0),
                                                                                        }
                                                                                }
                                                                        }
                                                                    };
                                                            #[doc(hidden)]
                                                            #[allow(non_upper_case_globals, unused_attributes,
                                                            unused_qualifications)]
                                                            const _: () =
                                                                {
                                                                        #[allow(unused_extern_crates, clippy :: useless_attribute)]
                                                                        extern crate serde as _serde;
                                                                        #[allow(unused_macros)]
                                                                        macro_rules! try {
                                                                            ($__expr : expr) =>
                                                                            {
                                                                                match $__expr
                                                                                {
                                                                                    _serde :: __private :: Ok(__val) => __val, _serde ::
                                                                                    __private :: Err(__err) =>
                                                                                    { return _serde :: __private :: Err(__err) ; }
                                                                                }
                                                                            }
                                                                        }
                                                                        #[automatically_derived]
                                                                        impl <'de> _serde::Deserialize<'de> for Location {
                                                                            fn deserialize<__D>(__deserializer: __D)
                                                                                -> _serde::__private::Result<Self, __D::Error> where
                                                                                __D: _serde::Deserializer<'de> {
                                                                                    #[allow(non_camel_case_types)]
                                                                                    #[doc(hidden)]
                                                                                    enum __Field { __field0, __field1, __field2, }
                                                                                    #[doc(hidden)]
                                                                                    struct __FieldVisitor;
                                                                                    impl <'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                                                                        type
                                                                                        Value
                                                                                        =
                                                                                        __Field;
                                                                                        fn expecting<'_, '_,
                                                                                            '_>(self: &'_ Self,
                                                                                            __formatter: &'_ mut _serde::__private::Formatter<>)
                                                                                            ->
                                                                                                _serde::__private::fmt::Result {
                                                                                                _serde::__private::Formatter::write_str(__formatter,
                                                                                                    "variant identifier")
                                                                                            }
                                                                                        fn visit_u64<__E>(self: Self, __value: u64)
                                                                                            -> _serde::__private::Result<Self::Value, __E> where
                                                                                            __E: _serde::de::Error {
                                                                                                match __value {
                                                                                                        0u64 => _serde::__private::Ok(__Field::__field0),
                                                                                                        1u64 => _serde::__private::Ok(__Field::__field1),
                                                                                                        2u64 => _serde::__private::Ok(__Field::__field2),
                                                                                                        _ =>
                                                                                                            _serde::__private::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                                                    &"variant index 0 <= i < 3")),
                                                                                                    }
                                                                                            }
                                                                                        fn visit_str<__E, '_>(self: Self, __value: &'_ str)
                                                                                            -> _serde::__private::Result<Self::Value, __E> where
                                                                                            __E: _serde::de::Error {
                                                                                                match __value {
                                                                                                        "bundled" => _serde::__private::Ok(__Field::__field0),
                                                                                                        "path" => _serde::__private::Ok(__Field::__field1),
                                                                                                        "url" => _serde::__private::Ok(__Field::__field2),
                                                                                                        _ => {
                                                                                                            _serde::__private::Err(_serde::de::Error::unknown_variant(__value,
                                                                                                                    VARIANTS))
                                                                                                        }
                                                                                                    }
                                                                                            }
                                                                                        fn visit_bytes<__E, '_>(self: Self, __value: &'_ [u8])
                                                                                            -> _serde::__private::Result<Self::Value, __E> where
                                                                                            __E: _serde::de::Error {
                                                                                                match __value {
                                                                                                        b"bundled" => _serde::__private::Ok(__Field::__field0),
                                                                                                        b"path" => _serde::__private::Ok(__Field::__field1),
                                                                                                        b"url" => _serde::__private::Ok(__Field::__field2),
                                                                                                        _ => {
                                                                                                            let __value = &_serde::__private::from_utf8_lossy(__value);
                                                                                                            _serde::__private::Err(_serde::de::Error::unknown_variant(__value,
                                                                                                                    VARIANTS))
                                                                                                        }
                                                                                                    }
                                                                                            }
                                                                                    }
                                                                                    impl <'de> _serde::Deserialize<'de> for __Field {
                                                                                        #[inline]
                                                                                        fn deserialize<__D>(__deserializer: __D)
                                                                                            -> _serde::__private::Result<Self, __D::Error> where
                                                                                            __D: _serde::Deserializer<'de> {
                                                                                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                                                    __FieldVisitor)
                                                                                            }
                                                                                    }
                                                                                    #[doc(hidden)]
                                                                                    struct __Visitor<'de> {
                                                                                        marker: _serde::__private::PhantomData<Location>,
                                                                                        lifetime: _serde::__private::PhantomData<&'de ()>,
                                                                                    }
                                                                                    impl <'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                                                                        type
                                                                                        Value
                                                                                        =
                                                                                        Location;
                                                                                        fn expecting<'_, '_,
                                                                                            '_>(self: &'_ Self,
                                                                                            __formatter: &'_ mut _serde::__private::Formatter<>)
                                                                                            ->
                                                                                                _serde::__private::fmt::Result {
                                                                                                _serde::__private::Formatter::write_str(__formatter,
                                                                                                    "enum Location")
                                                                                            }
                                                                                        fn visit_enum<__A>(self: Self, __data: __A)
                                                                                            -> _serde::__private::Result<Self::Value, __A::Error> where
                                                                                            __A: _serde::de::EnumAccess<'de> {
                                                                                                match match _serde::de::EnumAccess::variant(__data) {
                                                                                                                    _serde::__private::Ok(__val) => __val,
                                                                                                                    _serde::__private::Err(__err) => {
                                                                                                                        return _serde::__private::Err(__err);
                                                                                                                    }
                                                                                                                } {
                                                                                                        (__Field::__field0, __variant) =>
                                                                                                            _serde::__private::Result::map(_serde::de::VariantAccess::newtype_variant::<PathBuf>(__variant),
                                                                                                                Location::Bundled),
                                                                                                        (__Field::__field1, __variant) =>
                                                                                                            _serde::__private::Result::map(_serde::de::VariantAccess::newtype_variant::<PathBuf>(__variant),
                                                                                                                Location::Path),
                                                                                                        (__Field::__field2, __variant) =>
                                                                                                            _serde::__private::Result::map(_serde::de::VariantAccess::newtype_variant::<String>(__variant),
                                                                                                                Location::Url),
                                                                                                    }
                                                                                            }
                                                                                    }
                                                                                    #[doc(hidden)]
                                                                                    const VARIANTS: &'static [&'static str] =
                                                                                        &["bundled", "path", "url"];
                                                                                    _serde::Deserializer::deserialize_enum(__deserializer,
                                                                                        "Location", VARIANTS,
                                                                                        __Visitor{
                                                                                            marker: _serde::__private::PhantomData::<Location>,

                                                                                            lifetime: _serde::__private::PhantomData,})
                                                                                }
                                                                        }
                                                                    };
                                                            impl Location {
                                                                /// Make a relative Path absolute if possible, given the `root_dir`
                                                                fn normalize<'_,
                                                                    '_>(self: &'_ Self, root_dir: Option<&'_ PathBuf>)
                                                                    ->
                                                                        MrBundleResult<Location> {
                                                                        if let Location::Path(path) = self
                                                                                {
                                                                                        if path.is_relative()
                                                                                                {
                                                                                                        if let Some(dir) = root_dir
                                                                                                                {
                                                                                                                        Ok(Location::Path(match #[lang = "branch"](ffs::sync::canonicalize(dir.join(path)))
                                                                                                                                            {
                                                                                                                                        #[lang = "Break"] {  0: residual } =>
                                                                                                                                            #[allow(unreachable_code)]
                                                                                                                                            return #[lang = "from_residual"](residual),
                                                                                                                                        #[lang = "Continue"] {  0: val } =>
                                                                                                                                            #[allow(unreachable_code)]
                                                                                                                                            val,
                                                                                                                                    }))
                                                                                                                    } else {
                                                                                                                   Err(BundleError::RelativeLocalPath(path.to_owned()).into())
                                                                                                               }
                                                                                                            } else { Ok(self.clone()) } } else { Ok(self.clone()) } } }
                                                                                async fn resolve_local<'_>(path: &'_ Path)
                                                                                    ->
                                                                                        /*impl Trait*/ move
                                                                                    |mut _task_context: #[lang = "ResumeTy"]|
                                                                                    {
                                                                                            let path = path;
                                                                                            {
                                                                                                    let _t =
                                                                                                        {
                                                                                                                Ok(match #[lang = "branch"](match #[lang = "into_future"](ffs::read(path))
                                                                                                                                                    {
                                                                                                                                                mut __awaitee =>
                                                                                                                                                    loop {
                                                                                                                                                            match unsafe {
                                                                                                                                                                                #[lang = "poll"](#[lang = "new_unchecked"](&mut __awaitee),
                                                                                                                                                                                    #[lang = "get_context"](_task_context))
                                                                                                                                                                            } {
                                                                                                                                                                    #[lang = "Ready"] {  0: result } => break result,
                                                                                                                                                                    #[lang = "Pending"] {} => { }
                                                                                                                                                                }
                                                                                                                                                            _task_context = (yield ());
                                                                                                                                                        },
                                                                                                                                            }) {
                                                                                                                                #[lang = "Break"] {  0: residual } =>
                                                                                                                                    #[allow(unreachable_code)]
                                                                                                                                    return #[lang = "from_residual"](residual),
                                                                                                                                #[lang = "Continue"] {  0: val } =>
                                                                                                                                    #[allow(unreachable_code)]
                                                                                                                                    val,
                                                                                                                            }.into())
                                                                                                            };
                                                                                                    _t
                                                                                                }
                                                                                        }
                                                                                async fn resolve_remote<'_>(url: &'_ str)
                                                                                    ->
                                                                                        /*impl Trait*/ move
                                                                                    |mut _task_context: #[lang = "ResumeTy"]|
                                                                                    {
                                                                                            let url = url;
                                                                                            {
                                                                                                    let _t =
                                                                                                        {
                                                                                                                Ok(match #[lang = "branch"](match #[lang = "into_future"](match #[lang = "branch"](match #[lang = "into_future"](reqwest::get(url))
                                                                                                                                                                                                {
                                                                                                                                                                                            mut __awaitee =>
                                                                                                                                                                                                loop {
                                                                                                                                                                                                        match unsafe {
                                                                                                                                                                                                                            #[lang = "poll"](#[lang = "new_unchecked"](&mut __awaitee),
                                                                                                                                                                                                                                #[lang = "get_context"](_task_context))
                                                                                                                                                                                                                        } {
                                                                                                                                                                                                                #[lang = "Ready"] {  0: result } => break result,
                                                                                                                                                                                                                #[lang = "Pending"] {} => { }
                                                                                                                                                                                                            }
                                                                                                                                                                                                        _task_context = (yield ());
                                                                                                                                                                                                    },
                                                                                                                                                                                        }) {
                                                                                                                                                                            #[lang = "Break"] {  0: residual } =>
                                                                                                                                                                                #[allow(unreachable_code)]
                                                                                                                                                                                return #[lang = "from_residual"](residual),
                                                                                                                                                                            #[lang = "Continue"] {  0: val } =>
                                                                                                                                                                                #[allow(unreachable_code)]
                                                                                                                                                                                val,
                                                                                                                                                                        }.bytes()) {
                                                                                                                                                        mut __awaitee =>
                                                                                                                                                            loop {
                                                                                                                                                                    match unsafe {
                                                                                                                                                                                        #[lang = "poll"](#[lang = "new_unchecked"](&mut __awaitee),
                                                                                                                                                                                            #[lang = "get_context"](_task_context))
                                                                                                                                                                                    } {
                                                                                                                                                                            #[lang = "Ready"] {  0: result } => break result,
                                                                                                                                                                            #[lang = "Pending"] {} => { }
                                                                                                                                                                        }
                                                                                                                                                                    _task_context = (yield ());
                                                                                                                                                                },
                                                                                                                                                    }) {
                                                                                                                                        #[lang = "Break"] {  0: residual } =>
                                                                                                                                            #[allow(unreachable_code)]
                                                                                                                                            return #[lang = "from_residual"](residual),
                                                                                                                                        #[lang = "Continue"] {  0: val } =>
                                                                                                                                            #[allow(unreachable_code)]
                                                                                                                                            val,
                                                                                                                                    }.into_iter().collect::<Vec<_>>().into())
                                                                                                            };
                                                                                                    _t
                                                                                                }
                                                                                        } }
                                                                                mod manifest {
                                                                                    use std::path::PathBuf;
                                                                                    use crate::location::Location;
                                                                                    /// A Manifest describes the resources in a [`Bundle`](crate::Bundle) and how
                                                                                    /// to pack and unpack them.
                                                                                    ///
                                                                                    /// Regardless of the format of your Manifest, it must contain a set of Locations
                                                                                    /// describing where to find resources, and this trait must implement `locations`
                                                                                    /// properly to match the data contained in the manifest.
                                                                                    ///
                                                                                    /// You must also specify a relative path for the Manifest, and the extension
                                                                                    /// for the bundle file, if you are using the "packing" feature.
                                                                                    trait Manifest: Clone + Sized + PartialEq + Eq +
                                                                                        serde::Serialize + serde::de::DeserializeOwned {
                                                                                        /// The list of Locations referenced in the manifest data. This must be
                                                                                        /// correctly implemented to enable resource resolution.
                                                                                        fn locations<'_>(self: &'_ Self)
                                                                                        -> Vec<Location>;
                                                                                        /// Get only the Bundled locations
                                                                                        fn bundled_paths<'_>(self: &'_ Self)
                                                                                            ->
                                                                                                Vec<PathBuf> {
                                                                                                self.locations().into_iter().filter_map(|loc|
                                                                                                            {
                                                                                                                    if let Location::Bundled(path) = loc
                                                                                                                            { Some(path) } else { None }
                                                                                                                        }).collect() }
                                                                                            } }
                                                                                        mod resource {
                                                                                            /// Arbitrary opaque bytes representing a Resource in a [`Bundle`](crate::Bundle)
                                                                                            struct ResourceBytes(
                                                                                                #[serde(with = "serde_bytes")]
                                                                                                Vec<u8>);
                                                                                            #[automatically_derived]
                                                                                            impl ::core::fmt::Debug for ResourceBytes {
                                                                                                fn fmt<'_, '_,
                                                                                                    '_>(self: &'_ Self, f: &'_ mut ::core::fmt::Formatter<>)
                                                                                                    ->
                                                                                                        ::core::fmt::Result {
                                                                                                        ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                                                                                                            "ResourceBytes", &&self.0)
                                                                                                    }
                                                                                            }
                                                                                            #[automatically_derived]
                                                                                            impl ::core::clone::Clone for ResourceBytes {
                                                                                                #[inline]
                                                                                                fn clone<'_>(self: &'_ Self)
                                                                                                    ->
                                                                                                        ResourceBytes {
                                                                                                        ResourceBytes(::core::clone::Clone::clone(&self.0))
                                                                                                    }
                                                                                            }
                                                                                            #[automatically_derived]
                                                                                            impl ::core::marker::StructuralPartialEq for ResourceBytes {
                                                                                            }
                                                                                            #[automatically_derived]
                                                                                            impl ::core::cmp::PartialEq for ResourceBytes {
                                                                                                #[inline]
                                                                                                fn eq<'_, '_>(self: &'_ Self, other: &'_ ResourceBytes)
                                                                                                    -> bool { self.0 == other.0 }
                                                                                            }
                                                                                            #[automatically_derived]
                                                                                            impl ::core::marker::StructuralEq for ResourceBytes { }
                                                                                            #[automatically_derived]
                                                                                            impl ::core::cmp::Eq for ResourceBytes {
                                                                                                #[inline]
                                                                                                #[doc(hidden)]
                                                                                                #[no_coverage]
                                                                                                fn assert_receiver_is_total_eq<'_>(self: &'_ Self)
                                                                                                    -> () { let _: ::core::cmp::AssertParamIsEq<Vec<u8>>; }
                                                                                            }
                                                                                            #[automatically_derived]
                                                                                            impl ::core::hash::Hash for ResourceBytes {
                                                                                                fn hash<__H, '_, '_>(self: &'_ Self, state: &'_ mut __H)
                                                                                                    -> () where
                                                                                                    __H: ::core::hash::Hasher {
                                                                                                        ::core::hash::Hash::hash(&self.0, state)
                                                                                                    }
                                                                                            }
                                                                                            #[doc(hidden)]
                                                                                            #[allow(non_upper_case_globals, unused_attributes,
                                                                                            unused_qualifications)]
                                                                                            const _: () =
                                                                                                {
                                                                                                        #[allow(unused_extern_crates, clippy :: useless_attribute)]
                                                                                                        extern crate serde as _serde;
                                                                                                        #[allow(unused_macros)]
                                                                                                        macro_rules! try {
                                                                                                            ($__expr : expr) =>
                                                                                                            {
                                                                                                                match $__expr
                                                                                                                {
                                                                                                                    _serde :: __private :: Ok(__val) => __val, _serde ::
                                                                                                                    __private :: Err(__err) =>
                                                                                                                    { return _serde :: __private :: Err(__err) ; }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                        #[automatically_derived]
                                                                                                        impl _serde::Serialize for ResourceBytes {
                                                                                                            fn serialize<__S, '_>(self: &'_ Self, __serializer: __S)
                                                                                                                -> _serde::__private::Result<__S::Ok, __S::Error> where
                                                                                                                __S: _serde::Serializer {
                                                                                                                    _serde::Serializer::serialize_newtype_struct(__serializer,
                                                                                                                        "ResourceBytes",
                                                                                                                        {
                                                                                                                                #[doc(hidden)]
                                                                                                                                struct __SerializeWith<'__a> {
                                                                                                                                    values: (&'__a Vec<u8>,),
                                                                                                                                    phantom: _serde::__private::PhantomData<ResourceBytes>,
                                                                                                                                }
                                                                                                                                impl <'__a> _serde::Serialize for __SerializeWith<'__a> {
                                                                                                                                    fn serialize<__S, '_>(self: &'_ Self, __s: __S)
                                                                                                                                        -> _serde::__private::Result<__S::Ok, __S::Error> where
                                                                                                                                        __S: _serde::Serializer {
                                                                                                                                            serde_bytes::serialize(self.values.0, __s)
                                                                                                                                        }
                                                                                                                                }
                                                                                                                                &__SerializeWith{
                                                                                                                                        values: (&self.0,),

                                                                                                                                        phantom: _serde::__private::PhantomData::<ResourceBytes>,}
                                                                                                                            })
                                                                                                                }
                                                                                                        }
                                                                                                    };
                                                                                            #[doc(hidden)]
                                                                                            #[allow(non_upper_case_globals, unused_attributes,
                                                                                            unused_qualifications)]
                                                                                            const _: () =
                                                                                                {
                                                                                                        #[allow(unused_extern_crates, clippy :: useless_attribute)]
                                                                                                        extern crate serde as _serde;
                                                                                                        #[allow(unused_macros)]
                                                                                                        macro_rules! try {
                                                                                                            ($__expr : expr) =>
                                                                                                            {
                                                                                                                match $__expr
                                                                                                                {
                                                                                                                    _serde :: __private :: Ok(__val) => __val, _serde ::
                                                                                                                    __private :: Err(__err) =>
                                                                                                                    { return _serde :: __private :: Err(__err) ; }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                        #[automatically_derived]
                                                                                                        impl <'de> _serde::Deserialize<'de> for ResourceBytes {
                                                                                                            fn deserialize<__D>(__deserializer: __D)
                                                                                                                -> _serde::__private::Result<Self, __D::Error> where
                                                                                                                __D: _serde::Deserializer<'de> {
                                                                                                                    #[doc(hidden)]
                                                                                                                    struct __Visitor<'de> {
                                                                                                                        marker: _serde::__private::PhantomData<ResourceBytes>,
                                                                                                                        lifetime: _serde::__private::PhantomData<&'de ()>,
                                                                                                                    }
                                                                                                                    impl <'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                                                                                                        type
                                                                                                                        Value
                                                                                                                        =
                                                                                                                        ResourceBytes;
                                                                                                                        fn expecting<'_, '_,
                                                                                                                            '_>(self: &'_ Self,
                                                                                                                            __formatter: &'_ mut _serde::__private::Formatter<>)
                                                                                                                            ->
                                                                                                                                _serde::__private::fmt::Result {
                                                                                                                                _serde::__private::Formatter::write_str(__formatter,
                                                                                                                                    "tuple struct ResourceBytes")
                                                                                                                            }
                                                                                                                        #[inline]
                                                                                                                        fn visit_newtype_struct<__E>(self: Self, __e: __E)
                                                                                                                            -> _serde::__private::Result<Self::Value, __E::Error> where
                                                                                                                            __E: _serde::Deserializer<'de> {
                                                                                                                                let __field0: Vec<u8> =
                                                                                                                                    match serde_bytes::deserialize(__e) {
                                                                                                                                            _serde::__private::Ok(__val) => __val,
                                                                                                                                            _serde::__private::Err(__err) => {
                                                                                                                                                return _serde::__private::Err(__err);
                                                                                                                                            }
                                                                                                                                        };
                                                                                                                                _serde::__private::Ok(ResourceBytes(__field0))
                                                                                                                            }
                                                                                                                        #[inline]
                                                                                                                        fn visit_seq<__A>(self: Self, mut __seq: __A)
                                                                                                                            -> _serde::__private::Result<Self::Value, __A::Error> where
                                                                                                                            __A: _serde::de::SeqAccess<'de> {
                                                                                                                                let __field0 =
                                                                                                                                    match {
                                                                                                                                                        #[doc(hidden)]
                                                                                                                                                        struct __DeserializeWith<'de> {
                                                                                                                                                            value: Vec<u8>,
                                                                                                                                                            phantom: _serde::__private::PhantomData<ResourceBytes>,
                                                                                                                                                            lifetime: _serde::__private::PhantomData<&'de ()>,
                                                                                                                                                        }
                                                                                                                                                        impl <'de> _serde::Deserialize<'de> for
                                                                                                                                                            __DeserializeWith<'de> {
                                                                                                                                                            fn deserialize<__D>(__deserializer: __D)
                                                                                                                                                                -> _serde::__private::Result<Self, __D::Error> where
                                                                                                                                                                __D: _serde::Deserializer<'de> {
                                                                                                                                                                    _serde::__private::Ok(__DeserializeWith{
                                                                                                                                                                            value:
                                                                                                                                                                                match serde_bytes::deserialize(__deserializer) {
                                                                                                                                                                                        _serde::__private::Ok(__val) => __val,
                                                                                                                                                                                        _serde::__private::Err(__err) => {
                                                                                                                                                                                            return _serde::__private::Err(__err);
                                                                                                                                                                                        }
                                                                                                                                                                                    },

                                                                                                                                                                            phantom: _serde::__private::PhantomData,

                                                                                                                                                                            lifetime: _serde::__private::PhantomData,})
                                                                                                                                                                }
                                                                                                                                                        }
                                                                                                                                                        _serde::__private::Option::map(match _serde::de::SeqAccess::next_element::<__DeserializeWith<'de>>(&mut __seq)
                                                                                                                                                                        {
                                                                                                                                                                    _serde::__private::Ok(__val) => __val,
                                                                                                                                                                    _serde::__private::Err(__err) => {
                                                                                                                                                                        return _serde::__private::Err(__err);
                                                                                                                                                                    }
                                                                                                                                                                }, |__wrap| __wrap.value)
                                                                                                                                                    } {
                                                                                                                                            _serde::__private::Some(__value) => __value,
                                                                                                                                            _serde::__private::None => {
                                                                                                                                                return _serde::__private::Err(_serde::de::Error::invalid_length(0usize,
                                                                                                                                                            &"tuple struct ResourceBytes with 1 element"));
                                                                                                                                            }
                                                                                                                                        };
                                                                                                                                _serde::__private::Ok(ResourceBytes(__field0))
                                                                                                                            }
                                                                                                                    }
                                                                                                                    _serde::Deserializer::deserialize_newtype_struct(__deserializer,
                                                                                                                        "ResourceBytes",
                                                                                                                        __Visitor{
                                                                                                                            marker: _serde::__private::PhantomData::<ResourceBytes>,

                                                                                                                            lifetime: _serde::__private::PhantomData,})
                                                                                                                }
                                                                                                        }
                                                                                                    };
                                                                                            #[automatically_derived]
                                                                                            impl ::core::convert::From<Vec<u8>> for ResourceBytes {
                                                                                                #[inline]
                                                                                                fn from(original: Vec<u8>)
                                                                                                    -> ResourceBytes { ResourceBytes(original) }
                                                                                            }
                                                                                            impl ::core::ops::Deref for ResourceBytes {
                                                                                                type
                                                                                                Target
                                                                                                =
                                                                                                Vec<u8>;
                                                                                                #[inline]
                                                                                                fn deref<'_>(self: &'_ Self) -> &'_ Self::Target { &self.0 }
                                                                                            }
                                                                                            impl ResourceBytes {
                                                                                                /// Accessor
                                                                                                fn inner<'_>(self: &'_ Self)
                                                                                                    -> &'_ [u8] { self.0.as_slice() }
                                                                                                /// Convert to raw vec
                                                                                                fn into_inner(self: Self) -> Vec<u8> { self.0 }
                                                                                            }
                                                                                        }
                                                                                        mod util { }
                                                                                        use bundle::{};
                                                                                        use bundle::Bundle;
                                                                                        use bundle::RawBundle;
                                                                                        use encoding::{};
                                                                                        use encoding::decode;
                                                                                        use encoding::encode;
                                                                                        use location::Location;
                                                                                        use manifest::Manifest;
                                                                                        use resource::ResourceBytes;
